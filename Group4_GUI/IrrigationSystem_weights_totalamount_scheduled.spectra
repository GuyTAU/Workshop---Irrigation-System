/*
 * Auto-generated Spectra file
 */
 
import "./patterns/DwyerPatterns.spectra"
 
module IrrigationSystem			


/*******************/
/***** DEFINES *****/
/*******************/	
define minBoundDiff := 3; //3 IS THE MINIMUM DIFF! (NEED TO DECIDE ON A DIFF)
define isBelowRange := (moistureLevel < lowerBound);
define isAboveRange := (moistureLevel > upperBound);

define effectiveFlow := irrigationFlow + rainPower; //add 2 since temperature is decreasing the effective flow (if cold/medium +2/+1). 
define temperatureDecEffect := temperature + 1;

define nextIsNight := (((hour >= 21) & (hour <= 23)) | ((hour >= 0) & (hour <= 4)));


/****************************/
/***** SYSTEM VARIABLES *****/
/****************************/
sys Int (0..5) irrigationFlow; //flow provided by the irrigation system
sys boolean deviationAlert;

/*********************************/
/***** ENVIRONMENT VARIABLES *****/
/*********************************/
//irrigation mode (SWITCHES)
//env Int (0..1) mode; //0 - for automatic, 1 - for manual
env Int (0..2) mode; //0 - for automatic, 1 - for manual, 2 - for scheduled
env Int (0..5) manualModeUserFlow;

//SENSORS
env Int (0..3) rainPower;

env Int(0..23) hour;

env Int (0..15) moistureLevel;

env Int (0..2) temperature; // 0 - Cold, 1 - Medium, 2 - Hot

//Bounds of desired moisture level for our plant:
env Int (0..15) lowerBound; //NOTE: The eclipse shows only some of the starting states, since its number is quite big.
env Int (0..15) upperBound; //NOTE: The eclipse shows only some of the starting states, since its number is quite big.

//for scheduled mode:
//env Int(0..5)[24] schedule_table;
env Int(0..5)[12] schedule_table;


/***********************/
/***** ASSUMPTIONS *****/
/***********************/
//temperature assumptions
asm G nextIsNight -> ((next(temperature) = 0) | (next(temperature) = 1));

//Bounds cannot be changed once chosen by the user.
asm G (next (upperBound) = upperBound);
asm G (next (lowerBound) = lowerBound);
asm (lowerBound < upperBound);
asm (upperBound - lowerBound) > minBoundDiff; //NEED TO DECIDE ON A DIFF

//Temperature doesn't change drastically
asm G (temperature = 0) -> (!(next(temperature) = 2));
asm G (temperature = 2) -> (!(next(temperature) = 0));


//hour assumptions
asm G (hour = 23) -> (next(hour) = 23 | next(hour) = 0);  //keep increasing modulo 24
asm G (!(hour = 23)) -> ((next(hour) = hour) | (next(hour) = hour+1));
asm GF (hour != next(hour)); //ensure time is progressing

//moisture assumptions:

//
//asm G (moistureLevel + effectiveFlow - temperatureDecEffect < 0) -> (next(moistureLevel) = 0); //Avoid no-well separation.
//asm G (moistureLevel + effectiveFlow - temperatureDecEffect > 15) -> (next(moistureLevel) = 15); //Avoid no-well separation.
//asm G ((moistureLevel + effectiveFlow - temperatureDecEffect >= 0) & (moistureLevel + effectiveFlow - temperatureDecEffect <= 15)) ->
//			((next(moistureLevel) = moistureLevel + effectiveFlow - temperatureDecEffect) | 
//			(next(moistureLevel) = moistureLevel + effectiveFlow - temperatureDecEffect - 1) |
//			(next(moistureLevel) = moistureLevel + effectiveFlow - temperatureDecEffect + 1));



//EFFECTIVE FLOW IS 0 - NO EVAPORATION
asm G ((effectiveFlow = 0) & (moistureLevel - temperatureDecEffect < 0)) ->
			(next(moistureLevel) = 0); //Avoid no-well separation

asm G ((effectiveFlow = 0) & (moistureLevel - temperatureDecEffect > 15)) ->
			(next(moistureLevel) = 15); //Avoid no-well separation

asm G ((effectiveFlow = 0) & (moistureLevel - temperatureDecEffect >= 0) & (moistureLevel - temperatureDecEffect <= 15)) ->
			((next(moistureLevel) = moistureLevel - temperatureDecEffect) |
			(next(moistureLevel) = moistureLevel - temperatureDecEffect - 1) | //-1 for randomness
			(next(moistureLevel) = moistureLevel - temperatureDecEffect + 1));	//+1 for randomness
 
 
//EFFECTIVE FLOW IS GREATER THAN 0 - THERE IS EVAPORATION
asm G ((effectiveFlow = 0) & moistureLevel + (effectiveFlow + 2 - temperature) - temperatureDecEffect < 0) -> (next(moistureLevel) = 0); //Avoid no-well separation.
asm G ((effectiveFlow = 0) & moistureLevel + (effectiveFlow + 2 - temperature) - temperatureDecEffect > 15) -> (next(moistureLevel) = 15); //Avoid no-well separation.
asm G ((effectiveFlow = 0) & (moistureLevel + (effectiveFlow + 2 - temperature) - temperatureDecEffect >= 0) & (moistureLevel + (effectiveFlow + 2 - temperature) - temperatureDecEffect <= 15)) ->
			((next(moistureLevel) = moistureLevel + (effectiveFlow + 2 - temperature) - temperatureDecEffect) |
			(next(moistureLevel) = moistureLevel + (effectiveFlow + 2 - temperature) - temperatureDecEffect -1 ) | //-1 for randomness
			(next(moistureLevel) = moistureLevel + (effectiveFlow + 2 - temperature) - temperatureDecEffect + 1)); //+1 for randomness


/**********************/
/***** GUARANTEES *****/
/**********************/
//AUTOMATIC MODE:
gar G (((mode = 0) & isAboveRange) -> (irrigationFlow = 0)); //If we are above the range - do not irrigate. (there can be rain!)
gar pRespondsToS(((mode = 0) & isBelowRange), ((mode = 0) -> !deviationAlert)); //If we are below the range, ensures that we will eventually be above minimum range.
gar G deviationAlert = (isBelowRange | isAboveRange); //Alert in case of deviation.

//MANUAL MODE:
gar G (mode = 1) -> (irrigationFlow = manualModeUserFlow);


//SCHEDULED MODE:
//gar G (mode = 2) -> (irrigationFlow = schedule_table[hour]); //throwing error on: "schedule_table[hour]"
//USING INSTEAD OF ^, ALL OF THESE: 

gar G (mode = 2 & hour = 0) -> (irrigationFlow = schedule_table[0]);
gar G (mode = 2 & hour = 1) -> (irrigationFlow = schedule_table[1]);
gar G (mode = 2 & hour = 2) -> (irrigationFlow = schedule_table[2]);
gar G (mode = 2 & hour = 3) -> (irrigationFlow = schedule_table[3]);
gar G (mode = 2 & hour = 4) -> (irrigationFlow = schedule_table[4]);
gar G (mode = 2 & hour = 5) -> (irrigationFlow = schedule_table[5]);
gar G (mode = 2 & hour = 6) -> (irrigationFlow = schedule_table[6]);
gar G (mode = 2 & hour = 7) -> (irrigationFlow = schedule_table[7]);
gar G (mode = 2 & hour = 8) -> (irrigationFlow = schedule_table[8]);
gar G (mode = 2 & hour = 9) -> (irrigationFlow = schedule_table[9]);
gar G (mode = 2 & hour = 10) -> (irrigationFlow = schedule_table[10]);
gar G (mode = 2 & hour = 11) -> (irrigationFlow = schedule_table[11]);
/*
gar G (mode = 2 & hour = 12) -> (irrigationFlow = schedule_table[12]);
gar G (mode = 2 & hour = 13) -> (irrigationFlow = schedule_table[13]);
gar G (mode = 2 & hour = 14) -> (irrigationFlow = schedule_table[14]);
gar G (mode = 2 & hour = 15) -> (irrigationFlow = schedule_table[15]);
gar G (mode = 2 & hour = 16) -> (irrigationFlow = schedule_table[16]);
gar G (mode = 2 & hour = 17) -> (irrigationFlow = schedule_table[17]);
gar G (mode = 2 & hour = 18) -> (irrigationFlow = schedule_table[18]);
gar G (mode = 2 & hour = 19) -> (irrigationFlow = schedule_table[19]);
gar G (mode = 2 & hour = 20) -> (irrigationFlow = schedule_table[20]);
gar G (mode = 2 & hour = 21) -> (irrigationFlow = schedule_table[21]);
gar G (mode = 2 & hour = 22) -> (irrigationFlow = schedule_table[22]);
gar G (mode = 2 & hour = 23) -> (irrigationFlow = schedule_table[23]);
*/
 
 
//USING WEIGHTS TO SAVE WATER:
/*
weight -1
	(mode = 0) & (irrigationFlow = 1);
	
weight -2
	(mode = 0) & (irrigationFlow = 2);
	
weight -3
	(mode = 0) & (irrigationFlow = 3);
	
weight -4
	(mode = 0) & (irrigationFlow = 4);
	
weight -5
	(mode = 0) & (irrigationFlow = 5);
	
weight 5
	(mode = 0) & (irrigationFlow = 0) & !isBelowRange;
	
//weight -1
//	(mode = 0) & isBelowRange;
*/
 
 
//DAILY AMOUNT OF WATER USAGE IS RESTRICTED: 
/*
define maxWaterAmountPerDay := 1000;
 
 sys Int(0..1020) DailyWaterAmount;
 
 gar DailyWaterAmount = 0; //initial value is 0
 gar G (PREV(mode = 0) & (mode = 0) & (!(PREV(hour = 23) & (hour = 0 )))) -> (next(DailyWaterAmount) = DailyWaterAmount + irrigationFlow); //add current amount of water to total daily usage 
 gar G (PREV(mode = 0) & (mode = 0) & (PREV(hour = 23) & (hour = 0 ))) -> (next(DailyWaterAmount) = 0 + irrigationFlow); //restart, new day! 
 gar G (PREV(mode != 0) & (mode = 0)) -> (next(DailyWaterAmount) = 0 + irrigationFlow); //restart, back to automatic mode!
 gar G (mode = 0) -> (DailyWaterAmount <= maxWaterAmountPerDay); 
 
 */
 
 
 
 
 
 
 
 
 
 